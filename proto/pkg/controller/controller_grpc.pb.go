// Copyright 2022 Linkall Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: controller.proto

//go:generate mockgen -source=controller_grpc.pb.go -destination=mock_controller.go -package=controller
package controller

import (
	context "context"
	meta "github.com/vanus-labs/vanus/proto/pkg/meta"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	PingServer_Ping_FullMethodName = "/vanus.core.controller.PingServer/Ping"
)

// PingServerClient is the client API for PingServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PingServerClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PingResponse, error)
}

type pingServerClient struct {
	cc grpc.ClientConnInterface
}

func NewPingServerClient(cc grpc.ClientConnInterface) PingServerClient {
	return &pingServerClient{cc}
}

func (c *pingServerClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, PingServer_Ping_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PingServerServer is the server API for PingServer service.
// All implementations should embed UnimplementedPingServerServer
// for forward compatibility
type PingServerServer interface {
	Ping(context.Context, *emptypb.Empty) (*PingResponse, error)
}

// UnimplementedPingServerServer should be embedded to have forward compatible implementations.
type UnimplementedPingServerServer struct {
}

func (UnimplementedPingServerServer) Ping(context.Context, *emptypb.Empty) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}

// UnsafePingServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PingServerServer will
// result in compilation errors.
type UnsafePingServerServer interface {
	mustEmbedUnimplementedPingServerServer()
}

func RegisterPingServerServer(s grpc.ServiceRegistrar, srv PingServerServer) {
	s.RegisterService(&PingServer_ServiceDesc, srv)
}

func _PingServer_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PingServerServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PingServer_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PingServerServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PingServer_ServiceDesc is the grpc.ServiceDesc for PingServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PingServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vanus.core.controller.PingServer",
	HandlerType: (*PingServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _PingServer_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}

const (
	EventbusController_CreateEventbus_FullMethodName       = "/vanus.core.controller.EventbusController/CreateEventbus"
	EventbusController_CreateSystemEventbus_FullMethodName = "/vanus.core.controller.EventbusController/CreateSystemEventbus"
	EventbusController_DeleteEventbus_FullMethodName       = "/vanus.core.controller.EventbusController/DeleteEventbus"
	EventbusController_GetEventbus_FullMethodName          = "/vanus.core.controller.EventbusController/GetEventbus"
	EventbusController_ListEventbus_FullMethodName         = "/vanus.core.controller.EventbusController/ListEventbus"
	EventbusController_UpdateEventbus_FullMethodName       = "/vanus.core.controller.EventbusController/UpdateEventbus"
)

// EventbusControllerClient is the client API for EventbusController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventbusControllerClient interface {
	// grpc -> HTTP
	CreateEventbus(ctx context.Context, in *CreateEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error)
	CreateSystemEventbus(ctx context.Context, in *CreateEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error)
	DeleteEventbus(ctx context.Context, in *DeleteEventbusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetEventbus(ctx context.Context, in *GetEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error)
	ListEventbus(ctx context.Context, in *ListEventbusRequest, opts ...grpc.CallOption) (*ListEventbusResponse, error)
	UpdateEventbus(ctx context.Context, in *UpdateEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error)
}

type eventbusControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventbusControllerClient(cc grpc.ClientConnInterface) EventbusControllerClient {
	return &eventbusControllerClient{cc}
}

func (c *eventbusControllerClient) CreateEventbus(ctx context.Context, in *CreateEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error) {
	out := new(meta.Eventbus)
	err := c.cc.Invoke(ctx, EventbusController_CreateEventbus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventbusControllerClient) CreateSystemEventbus(ctx context.Context, in *CreateEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error) {
	out := new(meta.Eventbus)
	err := c.cc.Invoke(ctx, EventbusController_CreateSystemEventbus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventbusControllerClient) DeleteEventbus(ctx context.Context, in *DeleteEventbusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EventbusController_DeleteEventbus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventbusControllerClient) GetEventbus(ctx context.Context, in *GetEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error) {
	out := new(meta.Eventbus)
	err := c.cc.Invoke(ctx, EventbusController_GetEventbus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventbusControllerClient) ListEventbus(ctx context.Context, in *ListEventbusRequest, opts ...grpc.CallOption) (*ListEventbusResponse, error) {
	out := new(ListEventbusResponse)
	err := c.cc.Invoke(ctx, EventbusController_ListEventbus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventbusControllerClient) UpdateEventbus(ctx context.Context, in *UpdateEventbusRequest, opts ...grpc.CallOption) (*meta.Eventbus, error) {
	out := new(meta.Eventbus)
	err := c.cc.Invoke(ctx, EventbusController_UpdateEventbus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventbusControllerServer is the server API for EventbusController service.
// All implementations should embed UnimplementedEventbusControllerServer
// for forward compatibility
type EventbusControllerServer interface {
	// grpc -> HTTP
	CreateEventbus(context.Context, *CreateEventbusRequest) (*meta.Eventbus, error)
	CreateSystemEventbus(context.Context, *CreateEventbusRequest) (*meta.Eventbus, error)
	DeleteEventbus(context.Context, *DeleteEventbusRequest) (*emptypb.Empty, error)
	GetEventbus(context.Context, *GetEventbusRequest) (*meta.Eventbus, error)
	ListEventbus(context.Context, *ListEventbusRequest) (*ListEventbusResponse, error)
	UpdateEventbus(context.Context, *UpdateEventbusRequest) (*meta.Eventbus, error)
}

// UnimplementedEventbusControllerServer should be embedded to have forward compatible implementations.
type UnimplementedEventbusControllerServer struct {
}

func (UnimplementedEventbusControllerServer) CreateEventbus(context.Context, *CreateEventbusRequest) (*meta.Eventbus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEventbus not implemented")
}
func (UnimplementedEventbusControllerServer) CreateSystemEventbus(context.Context, *CreateEventbusRequest) (*meta.Eventbus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSystemEventbus not implemented")
}
func (UnimplementedEventbusControllerServer) DeleteEventbus(context.Context, *DeleteEventbusRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEventbus not implemented")
}
func (UnimplementedEventbusControllerServer) GetEventbus(context.Context, *GetEventbusRequest) (*meta.Eventbus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEventbus not implemented")
}
func (UnimplementedEventbusControllerServer) ListEventbus(context.Context, *ListEventbusRequest) (*ListEventbusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEventbus not implemented")
}
func (UnimplementedEventbusControllerServer) UpdateEventbus(context.Context, *UpdateEventbusRequest) (*meta.Eventbus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEventbus not implemented")
}

// UnsafeEventbusControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventbusControllerServer will
// result in compilation errors.
type UnsafeEventbusControllerServer interface {
	mustEmbedUnimplementedEventbusControllerServer()
}

func RegisterEventbusControllerServer(s grpc.ServiceRegistrar, srv EventbusControllerServer) {
	s.RegisterService(&EventbusController_ServiceDesc, srv)
}

func _EventbusController_CreateEventbus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEventbusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventbusControllerServer).CreateEventbus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventbusController_CreateEventbus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventbusControllerServer).CreateEventbus(ctx, req.(*CreateEventbusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventbusController_CreateSystemEventbus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEventbusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventbusControllerServer).CreateSystemEventbus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventbusController_CreateSystemEventbus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventbusControllerServer).CreateSystemEventbus(ctx, req.(*CreateEventbusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventbusController_DeleteEventbus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEventbusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventbusControllerServer).DeleteEventbus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventbusController_DeleteEventbus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventbusControllerServer).DeleteEventbus(ctx, req.(*DeleteEventbusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventbusController_GetEventbus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventbusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventbusControllerServer).GetEventbus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventbusController_GetEventbus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventbusControllerServer).GetEventbus(ctx, req.(*GetEventbusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventbusController_ListEventbus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventbusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventbusControllerServer).ListEventbus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventbusController_ListEventbus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventbusControllerServer).ListEventbus(ctx, req.(*ListEventbusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventbusController_UpdateEventbus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEventbusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventbusControllerServer).UpdateEventbus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventbusController_UpdateEventbus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventbusControllerServer).UpdateEventbus(ctx, req.(*UpdateEventbusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventbusController_ServiceDesc is the grpc.ServiceDesc for EventbusController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventbusController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vanus.core.controller.EventbusController",
	HandlerType: (*EventbusControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEventbus",
			Handler:    _EventbusController_CreateEventbus_Handler,
		},
		{
			MethodName: "CreateSystemEventbus",
			Handler:    _EventbusController_CreateSystemEventbus_Handler,
		},
		{
			MethodName: "DeleteEventbus",
			Handler:    _EventbusController_DeleteEventbus_Handler,
		},
		{
			MethodName: "GetEventbus",
			Handler:    _EventbusController_GetEventbus_Handler,
		},
		{
			MethodName: "ListEventbus",
			Handler:    _EventbusController_ListEventbus_Handler,
		},
		{
			MethodName: "UpdateEventbus",
			Handler:    _EventbusController_UpdateEventbus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}

const (
	EventlogController_ListSegment_FullMethodName          = "/vanus.core.controller.EventlogController/ListSegment"
	EventlogController_GetAppendableSegment_FullMethodName = "/vanus.core.controller.EventlogController/GetAppendableSegment"
)

// EventlogControllerClient is the client API for EventlogController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventlogControllerClient interface {
	ListSegment(ctx context.Context, in *ListSegmentRequest, opts ...grpc.CallOption) (*ListSegmentResponse, error)
	GetAppendableSegment(ctx context.Context, in *GetAppendableSegmentRequest, opts ...grpc.CallOption) (*GetAppendableSegmentResponse, error)
}

type eventlogControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventlogControllerClient(cc grpc.ClientConnInterface) EventlogControllerClient {
	return &eventlogControllerClient{cc}
}

func (c *eventlogControllerClient) ListSegment(ctx context.Context, in *ListSegmentRequest, opts ...grpc.CallOption) (*ListSegmentResponse, error) {
	out := new(ListSegmentResponse)
	err := c.cc.Invoke(ctx, EventlogController_ListSegment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventlogControllerClient) GetAppendableSegment(ctx context.Context, in *GetAppendableSegmentRequest, opts ...grpc.CallOption) (*GetAppendableSegmentResponse, error) {
	out := new(GetAppendableSegmentResponse)
	err := c.cc.Invoke(ctx, EventlogController_GetAppendableSegment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventlogControllerServer is the server API for EventlogController service.
// All implementations should embed UnimplementedEventlogControllerServer
// for forward compatibility
type EventlogControllerServer interface {
	ListSegment(context.Context, *ListSegmentRequest) (*ListSegmentResponse, error)
	GetAppendableSegment(context.Context, *GetAppendableSegmentRequest) (*GetAppendableSegmentResponse, error)
}

// UnimplementedEventlogControllerServer should be embedded to have forward compatible implementations.
type UnimplementedEventlogControllerServer struct {
}

func (UnimplementedEventlogControllerServer) ListSegment(context.Context, *ListSegmentRequest) (*ListSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSegment not implemented")
}
func (UnimplementedEventlogControllerServer) GetAppendableSegment(context.Context, *GetAppendableSegmentRequest) (*GetAppendableSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppendableSegment not implemented")
}

// UnsafeEventlogControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventlogControllerServer will
// result in compilation errors.
type UnsafeEventlogControllerServer interface {
	mustEmbedUnimplementedEventlogControllerServer()
}

func RegisterEventlogControllerServer(s grpc.ServiceRegistrar, srv EventlogControllerServer) {
	s.RegisterService(&EventlogController_ServiceDesc, srv)
}

func _EventlogController_ListSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventlogControllerServer).ListSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventlogController_ListSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventlogControllerServer).ListSegment(ctx, req.(*ListSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventlogController_GetAppendableSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppendableSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventlogControllerServer).GetAppendableSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventlogController_GetAppendableSegment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventlogControllerServer).GetAppendableSegment(ctx, req.(*GetAppendableSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventlogController_ServiceDesc is the grpc.ServiceDesc for EventlogController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventlogController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vanus.core.controller.EventlogController",
	HandlerType: (*EventlogControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSegment",
			Handler:    _EventlogController_ListSegment_Handler,
		},
		{
			MethodName: "GetAppendableSegment",
			Handler:    _EventlogController_GetAppendableSegment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}

const (
	SegmentController_QuerySegmentRouteInfo_FullMethodName    = "/vanus.core.controller.SegmentController/QuerySegmentRouteInfo"
	SegmentController_SegmentHeartbeat_FullMethodName         = "/vanus.core.controller.SegmentController/SegmentHeartbeat"
	SegmentController_RegisterSegmentServer_FullMethodName    = "/vanus.core.controller.SegmentController/RegisterSegmentServer"
	SegmentController_UnregisterSegmentServer_FullMethodName  = "/vanus.core.controller.SegmentController/UnregisterSegmentServer"
	SegmentController_ReportSegmentBlockIsFull_FullMethodName = "/vanus.core.controller.SegmentController/ReportSegmentBlockIsFull"
	SegmentController_ReportSegmentLeader_FullMethodName      = "/vanus.core.controller.SegmentController/ReportSegmentLeader"
)

// SegmentControllerClient is the client API for SegmentController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SegmentControllerClient interface {
	QuerySegmentRouteInfo(ctx context.Context, in *QuerySegmentRouteInfoRequest, opts ...grpc.CallOption) (*QuerySegmentRouteInfoResponse, error)
	SegmentHeartbeat(ctx context.Context, opts ...grpc.CallOption) (SegmentController_SegmentHeartbeatClient, error)
	RegisterSegmentServer(ctx context.Context, in *RegisterSegmentServerRequest, opts ...grpc.CallOption) (*RegisterSegmentServerResponse, error)
	UnregisterSegmentServer(ctx context.Context, in *UnregisterSegmentServerRequest, opts ...grpc.CallOption) (*UnregisterSegmentServerResponse, error)
	ReportSegmentBlockIsFull(ctx context.Context, in *SegmentHeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReportSegmentLeader(ctx context.Context, in *ReportSegmentLeaderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type segmentControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewSegmentControllerClient(cc grpc.ClientConnInterface) SegmentControllerClient {
	return &segmentControllerClient{cc}
}

func (c *segmentControllerClient) QuerySegmentRouteInfo(ctx context.Context, in *QuerySegmentRouteInfoRequest, opts ...grpc.CallOption) (*QuerySegmentRouteInfoResponse, error) {
	out := new(QuerySegmentRouteInfoResponse)
	err := c.cc.Invoke(ctx, SegmentController_QuerySegmentRouteInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) SegmentHeartbeat(ctx context.Context, opts ...grpc.CallOption) (SegmentController_SegmentHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &SegmentController_ServiceDesc.Streams[0], SegmentController_SegmentHeartbeat_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &segmentControllerSegmentHeartbeatClient{stream}
	return x, nil
}

type SegmentController_SegmentHeartbeatClient interface {
	Send(*SegmentHeartbeatRequest) error
	CloseAndRecv() (*SegmentHeartbeatResponse, error)
	grpc.ClientStream
}

type segmentControllerSegmentHeartbeatClient struct {
	grpc.ClientStream
}

func (x *segmentControllerSegmentHeartbeatClient) Send(m *SegmentHeartbeatRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *segmentControllerSegmentHeartbeatClient) CloseAndRecv() (*SegmentHeartbeatResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SegmentHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *segmentControllerClient) RegisterSegmentServer(ctx context.Context, in *RegisterSegmentServerRequest, opts ...grpc.CallOption) (*RegisterSegmentServerResponse, error) {
	out := new(RegisterSegmentServerResponse)
	err := c.cc.Invoke(ctx, SegmentController_RegisterSegmentServer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) UnregisterSegmentServer(ctx context.Context, in *UnregisterSegmentServerRequest, opts ...grpc.CallOption) (*UnregisterSegmentServerResponse, error) {
	out := new(UnregisterSegmentServerResponse)
	err := c.cc.Invoke(ctx, SegmentController_UnregisterSegmentServer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) ReportSegmentBlockIsFull(ctx context.Context, in *SegmentHeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SegmentController_ReportSegmentBlockIsFull_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) ReportSegmentLeader(ctx context.Context, in *ReportSegmentLeaderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SegmentController_ReportSegmentLeader_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SegmentControllerServer is the server API for SegmentController service.
// All implementations should embed UnimplementedSegmentControllerServer
// for forward compatibility
type SegmentControllerServer interface {
	QuerySegmentRouteInfo(context.Context, *QuerySegmentRouteInfoRequest) (*QuerySegmentRouteInfoResponse, error)
	SegmentHeartbeat(SegmentController_SegmentHeartbeatServer) error
	RegisterSegmentServer(context.Context, *RegisterSegmentServerRequest) (*RegisterSegmentServerResponse, error)
	UnregisterSegmentServer(context.Context, *UnregisterSegmentServerRequest) (*UnregisterSegmentServerResponse, error)
	ReportSegmentBlockIsFull(context.Context, *SegmentHeartbeatRequest) (*emptypb.Empty, error)
	ReportSegmentLeader(context.Context, *ReportSegmentLeaderRequest) (*emptypb.Empty, error)
}

// UnimplementedSegmentControllerServer should be embedded to have forward compatible implementations.
type UnimplementedSegmentControllerServer struct {
}

func (UnimplementedSegmentControllerServer) QuerySegmentRouteInfo(context.Context, *QuerySegmentRouteInfoRequest) (*QuerySegmentRouteInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySegmentRouteInfo not implemented")
}
func (UnimplementedSegmentControllerServer) SegmentHeartbeat(SegmentController_SegmentHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method SegmentHeartbeat not implemented")
}
func (UnimplementedSegmentControllerServer) RegisterSegmentServer(context.Context, *RegisterSegmentServerRequest) (*RegisterSegmentServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSegmentServer not implemented")
}
func (UnimplementedSegmentControllerServer) UnregisterSegmentServer(context.Context, *UnregisterSegmentServerRequest) (*UnregisterSegmentServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterSegmentServer not implemented")
}
func (UnimplementedSegmentControllerServer) ReportSegmentBlockIsFull(context.Context, *SegmentHeartbeatRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportSegmentBlockIsFull not implemented")
}
func (UnimplementedSegmentControllerServer) ReportSegmentLeader(context.Context, *ReportSegmentLeaderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportSegmentLeader not implemented")
}

// UnsafeSegmentControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SegmentControllerServer will
// result in compilation errors.
type UnsafeSegmentControllerServer interface {
	mustEmbedUnimplementedSegmentControllerServer()
}

func RegisterSegmentControllerServer(s grpc.ServiceRegistrar, srv SegmentControllerServer) {
	s.RegisterService(&SegmentController_ServiceDesc, srv)
}

func _SegmentController_QuerySegmentRouteInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySegmentRouteInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).QuerySegmentRouteInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SegmentController_QuerySegmentRouteInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).QuerySegmentRouteInfo(ctx, req.(*QuerySegmentRouteInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_SegmentHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SegmentControllerServer).SegmentHeartbeat(&segmentControllerSegmentHeartbeatServer{stream})
}

type SegmentController_SegmentHeartbeatServer interface {
	SendAndClose(*SegmentHeartbeatResponse) error
	Recv() (*SegmentHeartbeatRequest, error)
	grpc.ServerStream
}

type segmentControllerSegmentHeartbeatServer struct {
	grpc.ServerStream
}

func (x *segmentControllerSegmentHeartbeatServer) SendAndClose(m *SegmentHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *segmentControllerSegmentHeartbeatServer) Recv() (*SegmentHeartbeatRequest, error) {
	m := new(SegmentHeartbeatRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SegmentController_RegisterSegmentServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSegmentServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).RegisterSegmentServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SegmentController_RegisterSegmentServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).RegisterSegmentServer(ctx, req.(*RegisterSegmentServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_UnregisterSegmentServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterSegmentServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).UnregisterSegmentServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SegmentController_UnregisterSegmentServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).UnregisterSegmentServer(ctx, req.(*UnregisterSegmentServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_ReportSegmentBlockIsFull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).ReportSegmentBlockIsFull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SegmentController_ReportSegmentBlockIsFull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).ReportSegmentBlockIsFull(ctx, req.(*SegmentHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_ReportSegmentLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSegmentLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).ReportSegmentLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SegmentController_ReportSegmentLeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).ReportSegmentLeader(ctx, req.(*ReportSegmentLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SegmentController_ServiceDesc is the grpc.ServiceDesc for SegmentController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SegmentController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vanus.core.controller.SegmentController",
	HandlerType: (*SegmentControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QuerySegmentRouteInfo",
			Handler:    _SegmentController_QuerySegmentRouteInfo_Handler,
		},
		{
			MethodName: "RegisterSegmentServer",
			Handler:    _SegmentController_RegisterSegmentServer_Handler,
		},
		{
			MethodName: "UnregisterSegmentServer",
			Handler:    _SegmentController_UnregisterSegmentServer_Handler,
		},
		{
			MethodName: "ReportSegmentBlockIsFull",
			Handler:    _SegmentController_ReportSegmentBlockIsFull_Handler,
		},
		{
			MethodName: "ReportSegmentLeader",
			Handler:    _SegmentController_ReportSegmentLeader_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SegmentHeartbeat",
			Handler:       _SegmentController_SegmentHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "controller.proto",
}

const (
	TriggerController_CreateSubscription_FullMethodName       = "/vanus.core.controller.TriggerController/CreateSubscription"
	TriggerController_UpdateSubscription_FullMethodName       = "/vanus.core.controller.TriggerController/UpdateSubscription"
	TriggerController_DeleteSubscription_FullMethodName       = "/vanus.core.controller.TriggerController/DeleteSubscription"
	TriggerController_DisableSubscription_FullMethodName      = "/vanus.core.controller.TriggerController/DisableSubscription"
	TriggerController_ResumeSubscription_FullMethodName       = "/vanus.core.controller.TriggerController/ResumeSubscription"
	TriggerController_GetSubscription_FullMethodName          = "/vanus.core.controller.TriggerController/GetSubscription"
	TriggerController_ListSubscription_FullMethodName         = "/vanus.core.controller.TriggerController/ListSubscription"
	TriggerController_TriggerWorkerHeartbeat_FullMethodName   = "/vanus.core.controller.TriggerController/TriggerWorkerHeartbeat"
	TriggerController_RegisterTriggerWorker_FullMethodName    = "/vanus.core.controller.TriggerController/RegisterTriggerWorker"
	TriggerController_UnregisterTriggerWorker_FullMethodName  = "/vanus.core.controller.TriggerController/UnregisterTriggerWorker"
	TriggerController_ResetOffsetToTimestamp_FullMethodName   = "/vanus.core.controller.TriggerController/ResetOffsetToTimestamp"
	TriggerController_CommitOffset_FullMethodName             = "/vanus.core.controller.TriggerController/CommitOffset"
	TriggerController_SetDeadLetterEventOffset_FullMethodName = "/vanus.core.controller.TriggerController/SetDeadLetterEventOffset"
	TriggerController_GetDeadLetterEventOffset_FullMethodName = "/vanus.core.controller.TriggerController/GetDeadLetterEventOffset"
)

// TriggerControllerClient is the client API for TriggerController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerControllerClient interface {
	CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error)
	UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error)
	DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DisableSubscription(ctx context.Context, in *DisableSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResumeSubscription(ctx context.Context, in *ResumeSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error)
	ListSubscription(ctx context.Context, in *ListSubscriptionRequest, opts ...grpc.CallOption) (*ListSubscriptionResponse, error)
	TriggerWorkerHeartbeat(ctx context.Context, opts ...grpc.CallOption) (TriggerController_TriggerWorkerHeartbeatClient, error)
	RegisterTriggerWorker(ctx context.Context, in *RegisterTriggerWorkerRequest, opts ...grpc.CallOption) (*RegisterTriggerWorkerResponse, error)
	UnregisterTriggerWorker(ctx context.Context, in *UnregisterTriggerWorkerRequest, opts ...grpc.CallOption) (*UnregisterTriggerWorkerResponse, error)
	ResetOffsetToTimestamp(ctx context.Context, in *ResetOffsetToTimestampRequest, opts ...grpc.CallOption) (*ResetOffsetToTimestampResponse, error)
	CommitOffset(ctx context.Context, in *CommitOffsetRequest, opts ...grpc.CallOption) (*CommitOffsetResponse, error)
	SetDeadLetterEventOffset(ctx context.Context, in *SetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetDeadLetterEventOffset(ctx context.Context, in *GetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*GetDeadLetterEventOffsetResponse, error)
}

type triggerControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerControllerClient(cc grpc.ClientConnInterface) TriggerControllerClient {
	return &triggerControllerClient{cc}
}

func (c *triggerControllerClient) CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error) {
	out := new(meta.Subscription)
	err := c.cc.Invoke(ctx, TriggerController_CreateSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error) {
	out := new(meta.Subscription)
	err := c.cc.Invoke(ctx, TriggerController_UpdateSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerController_DeleteSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) DisableSubscription(ctx context.Context, in *DisableSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerController_DisableSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) ResumeSubscription(ctx context.Context, in *ResumeSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerController_ResumeSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error) {
	out := new(meta.Subscription)
	err := c.cc.Invoke(ctx, TriggerController_GetSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) ListSubscription(ctx context.Context, in *ListSubscriptionRequest, opts ...grpc.CallOption) (*ListSubscriptionResponse, error) {
	out := new(ListSubscriptionResponse)
	err := c.cc.Invoke(ctx, TriggerController_ListSubscription_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) TriggerWorkerHeartbeat(ctx context.Context, opts ...grpc.CallOption) (TriggerController_TriggerWorkerHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &TriggerController_ServiceDesc.Streams[0], TriggerController_TriggerWorkerHeartbeat_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &triggerControllerTriggerWorkerHeartbeatClient{stream}
	return x, nil
}

type TriggerController_TriggerWorkerHeartbeatClient interface {
	Send(*TriggerWorkerHeartbeatRequest) error
	CloseAndRecv() (*TriggerWorkerHeartbeatResponse, error)
	grpc.ClientStream
}

type triggerControllerTriggerWorkerHeartbeatClient struct {
	grpc.ClientStream
}

func (x *triggerControllerTriggerWorkerHeartbeatClient) Send(m *TriggerWorkerHeartbeatRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *triggerControllerTriggerWorkerHeartbeatClient) CloseAndRecv() (*TriggerWorkerHeartbeatResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TriggerWorkerHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *triggerControllerClient) RegisterTriggerWorker(ctx context.Context, in *RegisterTriggerWorkerRequest, opts ...grpc.CallOption) (*RegisterTriggerWorkerResponse, error) {
	out := new(RegisterTriggerWorkerResponse)
	err := c.cc.Invoke(ctx, TriggerController_RegisterTriggerWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) UnregisterTriggerWorker(ctx context.Context, in *UnregisterTriggerWorkerRequest, opts ...grpc.CallOption) (*UnregisterTriggerWorkerResponse, error) {
	out := new(UnregisterTriggerWorkerResponse)
	err := c.cc.Invoke(ctx, TriggerController_UnregisterTriggerWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) ResetOffsetToTimestamp(ctx context.Context, in *ResetOffsetToTimestampRequest, opts ...grpc.CallOption) (*ResetOffsetToTimestampResponse, error) {
	out := new(ResetOffsetToTimestampResponse)
	err := c.cc.Invoke(ctx, TriggerController_ResetOffsetToTimestamp_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) CommitOffset(ctx context.Context, in *CommitOffsetRequest, opts ...grpc.CallOption) (*CommitOffsetResponse, error) {
	out := new(CommitOffsetResponse)
	err := c.cc.Invoke(ctx, TriggerController_CommitOffset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) SetDeadLetterEventOffset(ctx context.Context, in *SetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerController_SetDeadLetterEventOffset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) GetDeadLetterEventOffset(ctx context.Context, in *GetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*GetDeadLetterEventOffsetResponse, error) {
	out := new(GetDeadLetterEventOffsetResponse)
	err := c.cc.Invoke(ctx, TriggerController_GetDeadLetterEventOffset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerControllerServer is the server API for TriggerController service.
// All implementations should embed UnimplementedTriggerControllerServer
// for forward compatibility
type TriggerControllerServer interface {
	CreateSubscription(context.Context, *CreateSubscriptionRequest) (*meta.Subscription, error)
	UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*meta.Subscription, error)
	DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*emptypb.Empty, error)
	DisableSubscription(context.Context, *DisableSubscriptionRequest) (*emptypb.Empty, error)
	ResumeSubscription(context.Context, *ResumeSubscriptionRequest) (*emptypb.Empty, error)
	GetSubscription(context.Context, *GetSubscriptionRequest) (*meta.Subscription, error)
	ListSubscription(context.Context, *ListSubscriptionRequest) (*ListSubscriptionResponse, error)
	TriggerWorkerHeartbeat(TriggerController_TriggerWorkerHeartbeatServer) error
	RegisterTriggerWorker(context.Context, *RegisterTriggerWorkerRequest) (*RegisterTriggerWorkerResponse, error)
	UnregisterTriggerWorker(context.Context, *UnregisterTriggerWorkerRequest) (*UnregisterTriggerWorkerResponse, error)
	ResetOffsetToTimestamp(context.Context, *ResetOffsetToTimestampRequest) (*ResetOffsetToTimestampResponse, error)
	CommitOffset(context.Context, *CommitOffsetRequest) (*CommitOffsetResponse, error)
	SetDeadLetterEventOffset(context.Context, *SetDeadLetterEventOffsetRequest) (*emptypb.Empty, error)
	GetDeadLetterEventOffset(context.Context, *GetDeadLetterEventOffsetRequest) (*GetDeadLetterEventOffsetResponse, error)
}

// UnimplementedTriggerControllerServer should be embedded to have forward compatible implementations.
type UnimplementedTriggerControllerServer struct {
}

func (UnimplementedTriggerControllerServer) CreateSubscription(context.Context, *CreateSubscriptionRequest) (*meta.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*meta.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) DisableSubscription(context.Context, *DisableSubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) ResumeSubscription(context.Context, *ResumeSubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) GetSubscription(context.Context, *GetSubscriptionRequest) (*meta.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) ListSubscription(context.Context, *ListSubscriptionRequest) (*ListSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) TriggerWorkerHeartbeat(TriggerController_TriggerWorkerHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method TriggerWorkerHeartbeat not implemented")
}
func (UnimplementedTriggerControllerServer) RegisterTriggerWorker(context.Context, *RegisterTriggerWorkerRequest) (*RegisterTriggerWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTriggerWorker not implemented")
}
func (UnimplementedTriggerControllerServer) UnregisterTriggerWorker(context.Context, *UnregisterTriggerWorkerRequest) (*UnregisterTriggerWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTriggerWorker not implemented")
}
func (UnimplementedTriggerControllerServer) ResetOffsetToTimestamp(context.Context, *ResetOffsetToTimestampRequest) (*ResetOffsetToTimestampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetOffsetToTimestamp not implemented")
}
func (UnimplementedTriggerControllerServer) CommitOffset(context.Context, *CommitOffsetRequest) (*CommitOffsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitOffset not implemented")
}
func (UnimplementedTriggerControllerServer) SetDeadLetterEventOffset(context.Context, *SetDeadLetterEventOffsetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDeadLetterEventOffset not implemented")
}
func (UnimplementedTriggerControllerServer) GetDeadLetterEventOffset(context.Context, *GetDeadLetterEventOffsetRequest) (*GetDeadLetterEventOffsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeadLetterEventOffset not implemented")
}

// UnsafeTriggerControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerControllerServer will
// result in compilation errors.
type UnsafeTriggerControllerServer interface {
	mustEmbedUnimplementedTriggerControllerServer()
}

func RegisterTriggerControllerServer(s grpc.ServiceRegistrar, srv TriggerControllerServer) {
	s.RegisterService(&TriggerController_ServiceDesc, srv)
}

func _TriggerController_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).CreateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_CreateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).CreateSubscription(ctx, req.(*CreateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_UpdateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_DeleteSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).DeleteSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_DeleteSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).DeleteSubscription(ctx, req.(*DeleteSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_DisableSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).DisableSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_DisableSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).DisableSubscription(ctx, req.(*DisableSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_ResumeSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).ResumeSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_ResumeSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).ResumeSubscription(ctx, req.(*ResumeSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_GetSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).GetSubscription(ctx, req.(*GetSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_ListSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).ListSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_ListSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).ListSubscription(ctx, req.(*ListSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_TriggerWorkerHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TriggerControllerServer).TriggerWorkerHeartbeat(&triggerControllerTriggerWorkerHeartbeatServer{stream})
}

type TriggerController_TriggerWorkerHeartbeatServer interface {
	SendAndClose(*TriggerWorkerHeartbeatResponse) error
	Recv() (*TriggerWorkerHeartbeatRequest, error)
	grpc.ServerStream
}

type triggerControllerTriggerWorkerHeartbeatServer struct {
	grpc.ServerStream
}

func (x *triggerControllerTriggerWorkerHeartbeatServer) SendAndClose(m *TriggerWorkerHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *triggerControllerTriggerWorkerHeartbeatServer) Recv() (*TriggerWorkerHeartbeatRequest, error) {
	m := new(TriggerWorkerHeartbeatRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TriggerController_RegisterTriggerWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterTriggerWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).RegisterTriggerWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_RegisterTriggerWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).RegisterTriggerWorker(ctx, req.(*RegisterTriggerWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_UnregisterTriggerWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterTriggerWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).UnregisterTriggerWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_UnregisterTriggerWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).UnregisterTriggerWorker(ctx, req.(*UnregisterTriggerWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_ResetOffsetToTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetOffsetToTimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).ResetOffsetToTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_ResetOffsetToTimestamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).ResetOffsetToTimestamp(ctx, req.(*ResetOffsetToTimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_CommitOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).CommitOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_CommitOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).CommitOffset(ctx, req.(*CommitOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_SetDeadLetterEventOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDeadLetterEventOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).SetDeadLetterEventOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_SetDeadLetterEventOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).SetDeadLetterEventOffset(ctx, req.(*SetDeadLetterEventOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_GetDeadLetterEventOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeadLetterEventOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).GetDeadLetterEventOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerController_GetDeadLetterEventOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).GetDeadLetterEventOffset(ctx, req.(*GetDeadLetterEventOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerController_ServiceDesc is the grpc.ServiceDesc for TriggerController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vanus.core.controller.TriggerController",
	HandlerType: (*TriggerControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubscription",
			Handler:    _TriggerController_CreateSubscription_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _TriggerController_UpdateSubscription_Handler,
		},
		{
			MethodName: "DeleteSubscription",
			Handler:    _TriggerController_DeleteSubscription_Handler,
		},
		{
			MethodName: "DisableSubscription",
			Handler:    _TriggerController_DisableSubscription_Handler,
		},
		{
			MethodName: "ResumeSubscription",
			Handler:    _TriggerController_ResumeSubscription_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _TriggerController_GetSubscription_Handler,
		},
		{
			MethodName: "ListSubscription",
			Handler:    _TriggerController_ListSubscription_Handler,
		},
		{
			MethodName: "RegisterTriggerWorker",
			Handler:    _TriggerController_RegisterTriggerWorker_Handler,
		},
		{
			MethodName: "UnregisterTriggerWorker",
			Handler:    _TriggerController_UnregisterTriggerWorker_Handler,
		},
		{
			MethodName: "ResetOffsetToTimestamp",
			Handler:    _TriggerController_ResetOffsetToTimestamp_Handler,
		},
		{
			MethodName: "CommitOffset",
			Handler:    _TriggerController_CommitOffset_Handler,
		},
		{
			MethodName: "SetDeadLetterEventOffset",
			Handler:    _TriggerController_SetDeadLetterEventOffset_Handler,
		},
		{
			MethodName: "GetDeadLetterEventOffset",
			Handler:    _TriggerController_GetDeadLetterEventOffset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TriggerWorkerHeartbeat",
			Handler:       _TriggerController_TriggerWorkerHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "controller.proto",
}

const (
	SnowflakeController_GetClusterStartTime_FullMethodName = "/vanus.core.controller.SnowflakeController/GetClusterStartTime"
	SnowflakeController_RegisterNode_FullMethodName        = "/vanus.core.controller.SnowflakeController/RegisterNode"
	SnowflakeController_UnregisterNode_FullMethodName      = "/vanus.core.controller.SnowflakeController/UnregisterNode"
)

// SnowflakeControllerClient is the client API for SnowflakeController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SnowflakeControllerClient interface {
	GetClusterStartTime(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*timestamppb.Timestamp, error)
	RegisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type snowflakeControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewSnowflakeControllerClient(cc grpc.ClientConnInterface) SnowflakeControllerClient {
	return &snowflakeControllerClient{cc}
}

func (c *snowflakeControllerClient) GetClusterStartTime(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*timestamppb.Timestamp, error) {
	out := new(timestamppb.Timestamp)
	err := c.cc.Invoke(ctx, SnowflakeController_GetClusterStartTime_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snowflakeControllerClient) RegisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SnowflakeController_RegisterNode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snowflakeControllerClient) UnregisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SnowflakeController_UnregisterNode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SnowflakeControllerServer is the server API for SnowflakeController service.
// All implementations should embed UnimplementedSnowflakeControllerServer
// for forward compatibility
type SnowflakeControllerServer interface {
	GetClusterStartTime(context.Context, *emptypb.Empty) (*timestamppb.Timestamp, error)
	RegisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error)
	UnregisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error)
}

// UnimplementedSnowflakeControllerServer should be embedded to have forward compatible implementations.
type UnimplementedSnowflakeControllerServer struct {
}

func (UnimplementedSnowflakeControllerServer) GetClusterStartTime(context.Context, *emptypb.Empty) (*timestamppb.Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterStartTime not implemented")
}
func (UnimplementedSnowflakeControllerServer) RegisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedSnowflakeControllerServer) UnregisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterNode not implemented")
}

// UnsafeSnowflakeControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SnowflakeControllerServer will
// result in compilation errors.
type UnsafeSnowflakeControllerServer interface {
	mustEmbedUnimplementedSnowflakeControllerServer()
}

func RegisterSnowflakeControllerServer(s grpc.ServiceRegistrar, srv SnowflakeControllerServer) {
	s.RegisterService(&SnowflakeController_ServiceDesc, srv)
}

func _SnowflakeController_GetClusterStartTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnowflakeControllerServer).GetClusterStartTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnowflakeController_GetClusterStartTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnowflakeControllerServer).GetClusterStartTime(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnowflakeController_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.UInt32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnowflakeControllerServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnowflakeController_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnowflakeControllerServer).RegisterNode(ctx, req.(*wrapperspb.UInt32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnowflakeController_UnregisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.UInt32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnowflakeControllerServer).UnregisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnowflakeController_UnregisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnowflakeControllerServer).UnregisterNode(ctx, req.(*wrapperspb.UInt32Value))
	}
	return interceptor(ctx, in, info, handler)
}

// SnowflakeController_ServiceDesc is the grpc.ServiceDesc for SnowflakeController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SnowflakeController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vanus.core.controller.SnowflakeController",
	HandlerType: (*SnowflakeControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterStartTime",
			Handler:    _SnowflakeController_GetClusterStartTime_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _SnowflakeController_RegisterNode_Handler,
		},
		{
			MethodName: "UnregisterNode",
			Handler:    _SnowflakeController_UnregisterNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}
