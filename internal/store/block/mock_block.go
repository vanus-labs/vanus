// Code generated by MockGen. DO NOT EDIT.
// Source: block.go

// Package block is a generated GoMock package.
package block

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	vanus "github.com/linkall-labs/vanus/internal/primitive/vanus"
	meta "github.com/linkall-labs/vanus/proto/pkg/meta"
)

// MockAppender is a mock of Appender interface.
type MockAppender struct {
	ctrl     *gomock.Controller
	recorder *MockAppenderMockRecorder
}

// MockAppenderMockRecorder is the mock recorder for MockAppender.
type MockAppenderMockRecorder struct {
	mock *MockAppender
}

// NewMockAppender creates a new mock instance.
func NewMockAppender(ctrl *gomock.Controller) *MockAppender {
	mock := &MockAppender{ctrl: ctrl}
	mock.recorder = &MockAppenderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppender) EXPECT() *MockAppenderMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockAppender) Append(ctx context.Context, entries ...Entry) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range entries {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Append", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockAppenderMockRecorder) Append(ctx interface{}, entries ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, entries...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockAppender)(nil).Append), varargs...)
}

// MockAppendContext is a mock of AppendContext interface.
type MockAppendContext struct {
	ctrl     *gomock.Controller
	recorder *MockAppendContextMockRecorder
}

// MockAppendContextMockRecorder is the mock recorder for MockAppendContext.
type MockAppendContextMockRecorder struct {
	mock *MockAppendContext
}

// NewMockAppendContext creates a new mock instance.
func NewMockAppendContext(ctrl *gomock.Controller) *MockAppendContext {
	mock := &MockAppendContext{ctrl: ctrl}
	mock.recorder = &MockAppendContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppendContext) EXPECT() *MockAppendContextMockRecorder {
	return m.recorder
}

// Full mocks base method.
func (m *MockAppendContext) Full() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Full")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Full indicates an expected call of Full.
func (mr *MockAppendContextMockRecorder) Full() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Full", reflect.TypeOf((*MockAppendContext)(nil).Full))
}

// FullEntry mocks base method.
func (m *MockAppendContext) FullEntry() Entry {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FullEntry")
	ret0, _ := ret[0].(Entry)
	return ret0
}

// FullEntry indicates an expected call of FullEntry.
func (mr *MockAppendContextMockRecorder) FullEntry() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FullEntry", reflect.TypeOf((*MockAppendContext)(nil).FullEntry))
}

// MarkFull mocks base method.
func (m *MockAppendContext) MarkFull() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MarkFull")
}

// MarkFull indicates an expected call of MarkFull.
func (mr *MockAppendContextMockRecorder) MarkFull() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkFull", reflect.TypeOf((*MockAppendContext)(nil).MarkFull))
}

// WriteOffset mocks base method.
func (m *MockAppendContext) WriteOffset() uint32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteOffset")
	ret0, _ := ret[0].(uint32)
	return ret0
}

// WriteOffset indicates an expected call of WriteOffset.
func (mr *MockAppendContextMockRecorder) WriteOffset() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteOffset", reflect.TypeOf((*MockAppendContext)(nil).WriteOffset))
}

// MockTwoPCAppender is a mock of TwoPCAppender interface.
type MockTwoPCAppender struct {
	ctrl     *gomock.Controller
	recorder *MockTwoPCAppenderMockRecorder
}

// MockTwoPCAppenderMockRecorder is the mock recorder for MockTwoPCAppender.
type MockTwoPCAppenderMockRecorder struct {
	mock *MockTwoPCAppender
}

// NewMockTwoPCAppender creates a new mock instance.
func NewMockTwoPCAppender(ctrl *gomock.Controller) *MockTwoPCAppender {
	mock := &MockTwoPCAppender{ctrl: ctrl}
	mock.recorder = &MockTwoPCAppenderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTwoPCAppender) EXPECT() *MockTwoPCAppenderMockRecorder {
	return m.recorder
}

// CommitAppend mocks base method.
func (m *MockTwoPCAppender) CommitAppend(ctx context.Context, entries ...Entry) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range entries {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommitAppend", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CommitAppend indicates an expected call of CommitAppend.
func (mr *MockTwoPCAppenderMockRecorder) CommitAppend(ctx interface{}, entries ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, entries...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitAppend", reflect.TypeOf((*MockTwoPCAppender)(nil).CommitAppend), varargs...)
}

// MarkFull mocks base method.
func (m *MockTwoPCAppender) MarkFull(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkFull", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkFull indicates an expected call of MarkFull.
func (mr *MockTwoPCAppenderMockRecorder) MarkFull(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkFull", reflect.TypeOf((*MockTwoPCAppender)(nil).MarkFull), ctx)
}

// NewAppendContext mocks base method.
func (m *MockTwoPCAppender) NewAppendContext(last *Entry) AppendContext {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewAppendContext", last)
	ret0, _ := ret[0].(AppendContext)
	return ret0
}

// NewAppendContext indicates an expected call of NewAppendContext.
func (mr *MockTwoPCAppenderMockRecorder) NewAppendContext(last interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewAppendContext", reflect.TypeOf((*MockTwoPCAppender)(nil).NewAppendContext), last)
}

// PrepareAppend mocks base method.
func (m *MockTwoPCAppender) PrepareAppend(ctx context.Context, appendCtx AppendContext, entries ...Entry) ([]Entry, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, appendCtx}
	for _, a := range entries {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PrepareAppend", varargs...)
	ret0, _ := ret[0].([]Entry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareAppend indicates an expected call of PrepareAppend.
func (mr *MockTwoPCAppenderMockRecorder) PrepareAppend(ctx, appendCtx interface{}, entries ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, appendCtx}, entries...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareAppend", reflect.TypeOf((*MockTwoPCAppender)(nil).PrepareAppend), varargs...)
}

// MockReader is a mock of Reader interface.
type MockReader struct {
	ctrl     *gomock.Controller
	recorder *MockReaderMockRecorder
}

// MockReaderMockRecorder is the mock recorder for MockReader.
type MockReaderMockRecorder struct {
	mock *MockReader
}

// NewMockReader creates a new mock instance.
func NewMockReader(ctrl *gomock.Controller) *MockReader {
	mock := &MockReader{ctrl: ctrl}
	mock.recorder = &MockReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReader) EXPECT() *MockReaderMockRecorder {
	return m.recorder
}

// Read mocks base method.
func (m *MockReader) Read(arg0 context.Context, arg1, arg2 int) ([]Entry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", arg0, arg1, arg2)
	ret0, _ := ret[0].([]Entry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockReaderMockRecorder) Read(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockReader)(nil).Read), arg0, arg1, arg2)
}

// MockBlock is a mock of Block interface.
type MockBlock struct {
	ctrl     *gomock.Controller
	recorder *MockBlockMockRecorder
}

// MockBlockMockRecorder is the mock recorder for MockBlock.
type MockBlockMockRecorder struct {
	mock *MockBlock
}

// NewMockBlock creates a new mock instance.
func NewMockBlock(ctrl *gomock.Controller) *MockBlock {
	mock := &MockBlock{ctrl: ctrl}
	mock.recorder = &MockBlockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBlock) EXPECT() *MockBlockMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockBlock) Close(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockBlockMockRecorder) Close(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockBlock)(nil).Close), arg0)
}

// HealthInfo mocks base method.
func (m *MockBlock) HealthInfo() *meta.SegmentHealthInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HealthInfo")
	ret0, _ := ret[0].(*meta.SegmentHealthInfo)
	return ret0
}

// HealthInfo indicates an expected call of HealthInfo.
func (mr *MockBlockMockRecorder) HealthInfo() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HealthInfo", reflect.TypeOf((*MockBlock)(nil).HealthInfo))
}

// ID mocks base method.
func (m *MockBlock) ID() vanus.ID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(vanus.ID)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockBlockMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockBlock)(nil).ID))
}

// MockClusterInfoSource is a mock of ClusterInfoSource interface.
type MockClusterInfoSource struct {
	ctrl     *gomock.Controller
	recorder *MockClusterInfoSourceMockRecorder
}

// MockClusterInfoSourceMockRecorder is the mock recorder for MockClusterInfoSource.
type MockClusterInfoSourceMockRecorder struct {
	mock *MockClusterInfoSource
}

// NewMockClusterInfoSource creates a new mock instance.
func NewMockClusterInfoSource(ctrl *gomock.Controller) *MockClusterInfoSource {
	mock := &MockClusterInfoSource{ctrl: ctrl}
	mock.recorder = &MockClusterInfoSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClusterInfoSource) EXPECT() *MockClusterInfoSourceMockRecorder {
	return m.recorder
}

// FillClusterInfo mocks base method.
func (m *MockClusterInfoSource) FillClusterInfo(info *meta.SegmentHealthInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "FillClusterInfo", info)
}

// FillClusterInfo indicates an expected call of FillClusterInfo.
func (mr *MockClusterInfoSourceMockRecorder) FillClusterInfo(info interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FillClusterInfo", reflect.TypeOf((*MockClusterInfoSource)(nil).FillClusterInfo), info)
}
